<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>base-knowledge</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="base-knowledge"><strong>base knowledge</strong></h2>



<h3 id="关于正则表达式">关于正则表达式:</h3>

<ol>
<li><p>正则表达式,(?&lt;=…)之前的字符串需要匹配表达式才能成功匹配.不消耗字符串内容. <br>
正则表达式,(?=…)之后的字符串需要匹配表达式才能成功匹配.不消耗字符串内容.</p>

<blockquote>
  <p>如:<code>pattern = re.compile(r'(?&lt;=[&gt;"])test(?=[&lt;"])')</code> <br>
  这正则表示当test字符串左右两边均为<code>[&gt;"]</code>中的其中一个字符时才能匹配成功.</p>
</blockquote></li>
<li><p>正则表达式,<code>(?&lt;!...)</code>之前的字符串需要不匹配表达式才能成功匹配.不消耗字符串内容. <br>
正则表达式,<code>(?!...)</code>之后的字符串需要不匹配表达式才能成功匹配.不消耗字符串内容.</p></li>
<li><p>匹配形如”///abc”的字符串,要求只按最后一个/进行split</p>

<p>b = re.split(‘/(?!/)’,a)</p></li>
<li><p><code>re.IGNORECASE</code> <br>
让正则表达式忽略大小写，这样一来，[A-Z]也可以匹配小写字母了。 <br>
re.DOTALL <br>
影响’.’的行为，平时’.’匹配除换行符以外的所有字符，指定了本标志以后，也可以匹配换行符。</p></li>
<li><p>List item</p></li>
</ol>



<h3 id="零碎知识">零碎知识</h3>

<ol>
<li><p>meld:在终端运行该命令,可对两个文件或两个文件夹进行对比.</p></li>
<li><p>Gen rule:</p>

<p><code>python steps/deploy/release_regex.py -l /home/aisp/hyq/HIS/KGQA/examples/data/AI_industry/rules/regex/rule_raw -f /home/aisp/hyq/HIS/genrule-byclass/temp -o /home/aisp/hyq/HIS/KGQA/examples/data/AI_industry/rules/regex/all-rule</code></p></li>
<li><p>ImportError: libfst.so.1: cannot open shared object file: No such file or directory <br>
解决方法:import sys <br>
sys.path #查看里面是否包含/usr/local/lib</p>

<p><strong>export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</strong></p>

<p>python -c “import fst” #检查是否运行成功</p></li>
<li><p>ls -lt:按时间排序.</p></li>
<li><p>网页端flask打开方式:</p>

<blockquote>
  <p>1.先启动flask_http_service/flask_app.py 5000 <br>
  2.再启动flask_web_client/flask_app.py 5001 <br>
  注:1.中的flask调用engine中的client.py查询数据库 2.中的flask调用1中的结果.</p>
</blockquote></li>
<li><p>另一种测试方式,启动flask_app.py后,使用curl命令在另一新开终端中发送命令.</p>

<blockquote>
  <p><code>curl -i -H "Content-Type:application/json" -X POST -d '{"query":"hinton发表的文章"}' http://10.10.111.250:5000/graph/query</code> <br>
  如果启动的是本地的服务器,后面的地址应改为相对应的地址,如: <br>
  curl -i -H “Content-Type:application/json” -X POST -d ‘{“query”:”hinton发表的文章”}’ <a href="http://0.0.0.0:5000/graph/query">http://0.0.0.0:5000/graph/query</a></p>
</blockquote></li>
<li><p>单元测试运行方式:<code>python3 -m pytest -s tests/test_engine.py</code> #-s参数可以在终端中看到test输出</p></li>
<li>一个可以看最新文章的网址:<a href="http://www.arxiv-sanity.com">http://www.arxiv-sanity.com</a></li>
<li><p>关于无偏估计的解释: <br>
比如我要对某个学校一个年级的上千个学生估计他们的平均水平（真实值，上帝才知道的数字），那么我决定抽样来计算。 <br>
我抽出一个10个人的样本，可以计算出一个均值。那么如果我下次重新抽样，抽到的10个人可能就不一样了，那么这个从样本里面计算出来的均值可能就变了，对不对？ <br>
因为这个均值是随着我抽样变化的，而我抽出哪10个人来计算这个数字是随机的，那么这个均值也是随机的。但是这个均值也会服从一个规律（一个分布），那就是如果我抽很多次样本，计算出很多个这样的均值，这么多均值们的平均数应该接近上帝才知道的真实平均水平。 <br>
如果你能理解<strong>“样本均值”</strong>其实也是一个<strong>随机变量</strong>，那么就可以理解为这个<strong>随机变量的期望是真实值</strong>，所以无偏（这是无偏的定义）；<strong>而它又是一个随机变量，只是估计而不精确地等于，所以是无偏估计量。</strong></p></li>
<li><p>一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法<code>__call__()</code>,像函数一样被调用,很多开源代码中均有体现,如nmt.</p></li>
<li><p>提取recodeId: <br>
<code>grep '"core": "/data/chat"' log/$yesterday.log | grep -o -P '"recordId": ".*?"' | awk -F ': ' '{print $2}' | sed 's/"//g' &gt; recordId/$yesterday.recordId</code></p></li>
<li><p>按第2列对文件内容进行排序,分隔符为tab:  <br>
<code>sort -n -k 2 -t \t test.txt -o test.txt</code> <br>
-o命令表示将排序后的内容存储于原文件中.</p></li>
<li><p>os.getcwd(): 返回当前的工作目录.</p></li>
<li><p>使用awk命令对文件内容进行洗牌:</p>

<p>awk ‘BEGIN{srand()}{b[rand()NR]=$0}END{for(x in b)print b[x]}’ test_result1 &gt;&gt; test</p></li>
<li><p>查看gpu使用情况:nvidia-smi</p></li>
<li><p>准确率|召回率|F值 <br>
准确率 = 提取出的正确信息条数 / 提取出的信息条数  =======&gt; 查准率 <br>
召回率 = 提取出的正确信息条数 / 样本中的信息条数 =======&gt; 查全率 <br>
F值  = 正确率 * 召回率 * 2 / (正确率 + 召回率)</p></li>
<li><p>u盘读取出错:  sudo ntfsfix /dev/sdb4</p></li>
<li><p>使用sed命令行去掉 &lt;200b&gt; <br>
<code>sed -i 's/\xe2\x80\x8b//g' inputfile</code></p></li>
<li><p>去除重复行</p>

<p>:g/^(.*)<span>$</span>\n\1$/d                      //去除重复行</p>

<p>shell脚本中去重:<code>sort -u input-file -o output-file</code></p></li>
<li><p>如果需要登录服务器，使用如下命令：</p>

<blockquote>
  <p>ssh tianjin <br>
  如果需要传文件，使用如下命令： <br>
  scp tianjin:/path/filename /localpath/ <br>
  以上两条命令都需要输入跳板机的密钥密码</p>
</blockquote></li>
<li><p>虚拟环境下安装python 3.5：</p>

<blockquote>
  <p>首先安装virtualenvwrapper，可以选择apt安装或者pip安装 <br>
  apt安装 <br>
  <span>$</span> sudo apt-get install virtualenvwrapper <br>
  pip安装 <br>
  <span>$</span> sudo pip install virtualenvwrapper <br>
  当你需要使用Python2开发项目时，建立一个Python2的虚拟环境： <br>
  <span>$</span> mkvirtualenv -p /usr/bin/python2 env27 <br>
  当你需要Python3开发时： <br>
  <span>$</span> mkvirtualenv -p /usr/bin/python3.4 env34 <br>
  然后可以随时切换不同的虚拟环境： <br>
  <span>$</span> workon env27  # 进入Python2环境 <br>
  <span>$</span> workon env34  # 进入Python3环境</p>
</blockquote></li>
<li><p>gf可打开光标下的路径，ctrl+o可退回之前页面 <br>
:tabnew[file]，在tab页中编辑打开文件，gt进行页面切换 <br>
shift + #:查找光标所在字符串</p></li>
<li><p>去掉vim 中的^M符号</p>

<blockquote>
  <p>：%s/^M//g <br>
  tr -d “\015”  douban_que_ans3</p>
</blockquote></li>
<li><p><code>grep -o 'div class=' tieba.htm | wc -l</code> 输出查找到的div class=的数目</p></li>
<li><p><code>grep -n http://tieba.baidu.com/f?kw=%E5%91%A8%E6%9D%B0%E4%BC%A6 spider-tieba_2017-05-05-09:02:39.log | grep -o '\[http.*\]' | sort -u</code></p></li>
<li><p><code>grep -P -o '&lt;a href.*?class="j_th_tit ".*?&lt;/a&gt;' tieba.html</code> 结果如下： <br>
<code>&lt;a href="/p/5089096303" title="</code>【JayCn】【地表最强】” target=”_blank” class=”j_th_tit “&gt;【JayCn】【地表最强】<code>&lt;/a&gt;</code></p></li>
<li><p>random.shuffle的函数原型为：random.shuffle(x[, random])，用于将一个列表中的元素打乱。 <br>
random.choice从序列中获取一个随机元素。其函数原型为：random.choice(sequence)。参数sequence表示一个有序类型。</p></li>
<li><p>json.dumps是将一个Python数据类型列表进行json格式的编码解析. <br>
解码python json格式，可以用这个模块的json.loads()函数的解析方法</p></li>
<li><p>终端命令：<code>Shift+Ctrl+T</code> 打开新的标签页 <br>
<code>ctrl + pageUp ctrl + pageDown</code>可在多个屏幕中进行切换</p></li>
<li><p><code>python tiebacontentParser.py | tee tieba.htm</code>,查看爬取的htm页面，tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p></li>
<li>yw //复制从光标开始到词尾的字符。ndw或ndW：删除光标处开始及其后的n-1个字</li>
<li>grep ‘failed to parse’ log/spider-shiwanwhy_2017-04-24-11:14:22.log | awk -F ‘with parser’ ‘{print $2}’ | sort -u</li>
<li><p>du -sh pages:查看文件大小。 <br>
wc -l pages：查看文件数量</p></li>
<li><p>Robomongo连接至服务器，在create中应设置服务器的ip地址，例如：10.12.8.18</p></li>
<li><p>lxml: itertext(): <br>
Creates a text iterator. The iterator loops over this element and all subelements, in document order, and returns all inner text.</p></li>
<li><p>import sys <br>
sys.path.append(’引用模块的地址’)</p></li>
<li><p>日志logging模块：<a href="http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html">http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html</a></p></li>
<li>sys.argv[]是用来获取命令行参数的，sys.argv[0]表示代码本身文件路径，所以参数从1开始。</li>
<li><a href="http://www.json.cn/">http://www.json.cn/</a>在线json解析</li>
</ol>

<h3 id="git知识">Git知识</h3>

<ol>
<li><p>Git push冲突的解决方法:(both modified)</p>

<blockquote>
  <p>1.<code>git add xxx</code> <br>
  2.<code>git commit -m xx</code> <br>
  3.<code>git push  #! [rejected]        master -&gt; master (fetch first)</code> <br>
  4.<code>git pull –rebase</code> <br>
  5.<code>git rebase –continue # examples/data/AI_industry/rules/rules.txt: needs merge,You must edit all merge conflicts and then mark them as resolved using git add</code> <br>
  6.<code>#merge file</code> <br>
  7.<code>git rebase –continue</code> <br>
  8.<code>if 7 fail: git rebase pull –rebase then 7</code></p>
</blockquote></li>
<li><p>从git里将jieba引入到服务器： <br>
git clone <a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a> <br>
mv jieba/ jieba_t <br>
cp jieba_t/jieba jieba -r</p></li>
<li><ol><li></li></ol></li>
</ol>



<h3 id="vim知识">Vim知识</h3>

<ol>
<li>vim中从第n行开始到到最后一行进行替换 <br>
<code>:n,$s/vivian/sky/g</code>带g表示替换所有,不带只替换第一个 <br>
复制多行,<code>:10,20 co 21</code>, 表示复制第10行到第20行,并放到21行</li>
<li>vim 查找字符串出现的次数 <br>
在所有行中查找 字符串 出现的次数 <br>
<code>:%s/字符串/&amp;/gn</code> <br>
在m和n行之间查找 字符串 出现的次数 <br>
<code>:m,ns/字符串/&amp;/gn</code></li>
<li>vim注释多行方法：1、进入vi/vim编辑器，按CTRL+V进入可视化模式（VISUAL BLOCK）。2、移动光标上移或者下移，选中多行的开头。3、选择完毕后，按大写的的I键，此时下方会提示进入“insert”模式，输入你要插入的注释符，最后按ESC键，多行代码被注释</li>
<li>:nohl, 取消vim中搜索高亮显示</li>
<li><p>vim编辑快捷键：</p>

<blockquote>
  <p>复制一行：yy <br>
  粘贴：p <br>
  删除一个单词：dw， 删除一个单词并进入插入模式：cw <br>
  删除一行：dd, 删除后进入插入模式用cc或者S <br>
  撤销：u <br>
  删除到行尾：D或C</p>
</blockquote></li>
<li><p>List item</p></li>
</ol>



<h3 id="数据库相关">数据库相关</h3>

<ol>
<li>Mogo查询:<code>db.getCollection('newlog').find({'message.core': /chat/})</code></li>
</ol>



<h3 id="tensorflow-相关">tensorflow 相关</h3>

<ol>
<li><p>tensorflow中限制任务占用显存大小方法:</p>

<blockquote>
  <p>1.按比例预留: <br>
  tf_config = tensorflow.ConfigProto() <br>
  tf_config.gpu_options.per_process_gpu_memory_fraction = 0.5 # 分配50% <br>
  session = tensorflow.Session(config=tf_config) <br>
  2.自适应然后自动增长 <br>
  tf_config = tensorflow.ConfigProto() <br>
  tf_config.gpu_options.allow_growth = True # 自适应 <br>
  session = tensorflow.Session(config=tf_config)</p>
</blockquote></li>
<li><p>tensorflow中使用gpu时,可以在session中加选项,如: <br>
<code>with tf.Session(config=tf.ConfigProto(allow_soft_placement=True, log_device_placement=True))</code> <br>
其中 allow_soft_placement能让tensorflow遇到无法用GPU跑的数据时,自动切换成CPU进行. log_device_placement则记录一些日志.</p></li>
<li><p>关于集群中安装tensorflow:</p>

<blockquote>
  <p>3.1.集群中已经装好<code>python-pip python-dev python-virtualenv</code>等环境,只需下载<code>virtualenv</code>的二进制文件,通过运行<code>python virtualenv-15.1.0/virtualenv.py –system-site-packages env</code>继承系统的环境. <br>
  3.2.启动虚拟环境,<code>source env/bin/activate</code> <br>
  进入虚拟交互环境. <br>
  3.3.运行<code>pip install –upgrade tensorflow-gpu</code> <br>
  若第3步出错,(资源请求错误),转4 <br>
  3.4.<code>pip install –upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-1.2.1-cp27-none-linux_x86_64.whl</code> <br>
  3.5.不用时,关闭虚拟环境,<code>deactivate</code> <br>
  注:集群中已经安装过<code>cuda</code>,需将<code>cuda</code>目录加入<code>~/.bashrc</code>文件中,将如下代码加入: <br>
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64 <br>
  之后,<code>source ~/.bashrc</code></p>
  
  <p>其中遇到的bug记录如下(安装完后运行出错): <br>
  Traceback (most recent call last): <br>
  File “”, line 1, in  <br>
  File “/aifs/users/xyc43/env/lib/python2.7/site-packages/tensorflow/<strong>init</strong>.py”, line 24, in  <br>
  from tensorflow.python import * <br>
  File “/aifs/users/xyc43/env/lib/python2.7/site-packages/tensorflow/python/<strong>init</strong>.py”, line 49, in  <br>
  from tensorflow.python import pywrap_tensorflow <br>
  File “/aifs/users/xyc43/env/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow.py”, line 52, in  <br>
  raise ImportError(msg) <br>
  ImportError: Traceback (most recent call last): <br>
  File “/aifs/users/xyc43/env/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow.py”, line 41, in  <br>
  from tensorflow.python.pywrap_tensorflow_internal import * <br>
  File “/aifs/users/xyc43/env/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow_internal.py”, line 28, in  <br>
  _pywrap_tensorflow_internal = swig_import_helper() <br>
  File “/aifs/users/xyc43/env/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow_internal.py”, line 24, in swig_import_helper <br>
  _mod = imp.load_module(‘_pywrap_tensorflow_internal’, fp, pathname, description) <br>
  ImportError: libcusolver.so.8.0: cannot open shared object file: No such file or directory <br>
  Failed to load the native TensorFlow runtime. <br>
  See <a href="https://www.tensorflow.org/install/install_sources#common_installation_problems">https://www.tensorflow.org/install/install_sources#common_installation_problems</a> <br>
  for some common reasons and solutions.  Include the entire stack trace <br>
  above this error message when asking for help. <br>
  解决方法:将cuda路径加入~/.bashrc中</p>
</blockquote></li>
<li><p>tensorboard可视化： </p>

<blockquote>
  <p>python ~/.local/lib/python2.7/site-packages/tensorflow/tensorboard/tensorboard.py –logdir=”./graphs” –port 6006 <br>
  或者：tensorboard –logdir=”./graphs” –port 6006 <br>
  <a href="http://localhost:6006/">http://localhost:6006/</a></p>
</blockquote></li>
<li><p>List item</p></li>
</ol>



<h3 id="docker相关">Docker相关</h3>

<ol>
<li>创建Dockerfile</li>
<li><p>使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p>

<blockquote>
  <p>docker build -t runoob/centos:6.7 . <br>
  -t:指定要创建的目标镜像名 <br>
   . ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</p>
</blockquote></li>
<li><p><code>docker run -p 6001:50001 -t -i hyq/kgqa:1.2</code></p>

<blockquote>
  <p>50001端口为dockerfile中指定http服务器的端口,使用-p命令,将其映射至本机的6001端口,并修改flask_web.py中的默认端口号,使之与6001对应.运行时,另制定flask_web.py端口号,如7001,即可成功运行.</p>
</blockquote></li>
<li><p>使用命令:<code>docker exec $IMAGE_ID ls</code> 可以查看该docker中的目录.</p></li>
<li>使用命令:<code>docker exec $IMAGE_ID cat engine.log</code> 可查看docker服务器中的log.</li>
<li><code>docker image rm -f IMAGEID</code>删除docker image</li>
</ol>

<h3 id="项目相关">项目相关</h3>

<ol>
<li><p>flask中,从外部传参给函数内部:</p>

<blockquote>
  <p>from flask import app <br>
  app.config[‘engine’] = KGQAEngine(CONFIG_PATH)  <br>
  #在函数内部使用app.config[‘engine’]可获取从外部传入的参数,此处是KGQAEngine(CONFIG_PATH)  <br>
  存在函数: <br>
  def _query(q, verbose=False):  <br>
      res = app.config[‘engine’].answer(q)</p>
</blockquote></li>
 2. 
</ol></div></body>
</html>